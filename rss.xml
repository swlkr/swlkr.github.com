<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:swlkr-com:feed</id><updated>July 20 2018</updated><title type="text">swlkr</title><link rel="self" href="http://swlkr.com/rss.xml"></link><entry><title>The BIG, BEAUTIFUL Guide to Coast on Clojure</title><updated>July 20 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/07-20-2018-the-big-beautiful-guide-to-coast.html"></link><id>urn:swlkr-com:feed:post:The BIG, BEAUTIFUL Guide to Coast on Clojure</id><content type="html">&lt;p&gt;Getting started with coast on clojure is easy! That's kind of the whole point of the thing. Let's make a blog called... bloggg. Points for originality.&lt;/p&gt;&lt;h2&gt;Start here&lt;/h2&gt;&lt;pre&gt;&lt;code class="bash"&gt;coast new bloggg
cd bloggg
git init
git commit -am &amp;quot;Initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Alright, now there's a folder called bloggg, here's what's inside:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;.
├── Makefile
├── README.md
├── bin
│   └── nrepl.clj
├── deps.edn
├── resources
│   └── public
│       ├── css
│       │   └── app.css
│       └── js
│           └── app.js
├── src
│   ├── components.clj
│   ├── controllers
│   │   └── home.clj
│   ├── routes.clj
│   ├── server.clj
│   └── views
│       ├── errors.clj
│       └── home.clj
└── test
└── server&amp;#95;test.clj

9 directories, 13 files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not too much stuff, but still enough to be confusing. Here's how it's laid out, the src/routes.clj is where everything goes down, it's the map to the rest of the app, every function that runs code and every url is here. There's also components which you can use to make your own custom html elements with clojure, so you don't have to worry about styles and things across elements or complex css issues where like some things have padding and some don't. The first thing I do in all of my coast projects is add a css framework, in this case it's tachyons:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;wget -P resources/public/css https://raw.githubusercontent.com/tachyons-css/tachyons/master/css/tachyons.min.css
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let's add that to the layout function which wraps all of your views in some common html, add this underneath the &lt;code&gt;&amp;#91;:head&amp;#93;&lt;/code&gt; part&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn layout &amp;#91;request body&amp;#93;
  &amp;#91;:html
    &amp;#91;:head
     &amp;#91;:meta {:name &amp;quot;viewport&amp;quot; :content &amp;quot;width=device-width, initial-scale=1&amp;quot;}&amp;#93;
     &amp;#91;:link {:href &amp;quot;/css/app.css&amp;quot; :type &amp;quot;text/css&amp;quot; :rel &amp;quot;stylesheet&amp;quot;}&amp;#93;
     ; right here
     &amp;#91;:link {:href &amp;quot;/css/tachyons.min.css&amp;quot; :type &amp;quot;text/css&amp;quot; :rel &amp;quot;stylesheet&amp;quot;}&amp;#93;&amp;#93;
    &amp;#91;:body
     body
     &amp;#91;:script {:src &amp;quot;/js/app.js&amp;quot; :type &amp;quot;text/javascript&amp;quot;}&amp;#93;&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's run the app to see our changes:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;make nrepl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then connect to that repl server on port 7888. With atom and proto-repl this looks like Option + Cmd + Y then Enter. Now that you're in a repl navigate over to server.clj and run the -main function to start the development server and subsequently reload any code: (-main).&lt;/p&gt;&lt;p&gt;This is the beauty of clojure, code reloading is built into the language, so any major changes to your code even outside of the framework will get picked up with a call to (-main)! Amaze. Alright. It's time to get down to business and write some code.&lt;/p&gt;&lt;h2&gt;Logging&lt;/h2&gt;&lt;p&gt;Now head on over to localhost:1337 in your browser. Sweet, we have some html rendering! That's half the battle! You'll also notice in the same terminal where the repl server is running, there's output every time you visit a page that looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;GET / controllers.home/index 200 text/html; charset=utf-8 12ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's the coast logger working there and it only shows you a few things currently: the http method, the url, the route function that got called, the http response and which content type the response was along with how long the whole thing took.&lt;/p&gt;&lt;h2&gt;Database migrations&lt;/h2&gt;&lt;p&gt;Let's add authors (since you can't just have posts lying around without someone to write them) to the data with some sweet, sweet schema action.&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;coast gen schema add-authors
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The name here isn't super important, it's just nice to refer to things by name You should have a new file in &lt;code&gt;resources/migrations/&lt;/code&gt; named &lt;code&gt;{timestamp}-add-authors&lt;/code&gt;. Let's add some text to it:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; {timestamp}-add-authors

&amp;#91;{:db/ident :author/nickname
  :db/type &amp;quot;text&amp;quot;}

 {:db/ident :author/email
  :db/type &amp;quot;text&amp;quot;}

 {:db/col :author/password
  :db/type &amp;quot;text&amp;quot;
  :db/nil? false}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before we try to run a migration, let's make a new database for this project. The database name is a combination of the name of the project and the current environment which by default is "dev" there are three possible environments, dev, test and prod, although for the sake of this tutorial, I'll be focusing on dev.&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;make db/create

Database bloggg&amp;#95;dev created successfully
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let's add the authors schema to the db:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;make db/migrate

-- Migrating:  20180717140955&amp;#95;add&amp;#95;authors ---------------------

&amp;#91;#:db{:ident :author/nickname, :type text} #:db{:ident :author/email, :type text} #:db{:col :author/password, :type text, :nil? false}&amp;#93;

-- 20180717140955&amp;#95;add&amp;#95;authors ---------------------

20180717140955&amp;#95;add&amp;#95;authors migrated successfully
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Routing&lt;/h2&gt;&lt;p&gt;Sweet, it worked with some nice output too! Alright, now let's our authors sign in, out and up. We'll start with sign up. Add a new route and a new file named author:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;touch src/author.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are the routes we need, one to show the sign up form and the other to POST it.&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns routes
  &amp;#40;:require &amp;#91;coast.router&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; `home/index :home&amp;#93;
             ; -- these two here --
             &amp;#91;:get &amp;quot;/sign-up&amp;quot; `author/sign-up :author/sign-up&amp;#93;
             &amp;#91;:post &amp;quot;/authors&amp;quot; `author/create :author/create&amp;#93;&amp;#93;&amp;#41;
             ; -- these two here --

&amp;#40;def url-for &amp;#40;coast.router/url-for-routes routes&amp;#41;&amp;#41;
&amp;#40;def action-for &amp;#40;coast.router/action-for-routes routes&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before we continue we're going to need another dependency. Coast doesn't come with any password hashing stuff, so we're going to grab &lt;a href='https://funcool.github.io/buddy-hashers/latest/'&gt;buddy.hashers&lt;/a&gt; to get it going. Stop your repl and add this to &lt;code&gt;deps.edn&lt;/code&gt; under the &lt;code&gt;:deps&lt;/code&gt; key&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;buddy/buddy-hashers {:mvn/version &amp;quot;1.3.0&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Pages&lt;/h2&gt;&lt;p&gt;Normally, I would be writing about models, views and controllers, but with how small clojure code is and with some recent advancements in database access in coast, I can safely put all code related to pages in one file named after the pages related to it, here's what I mean:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; src/author.clj

&amp;#40;ns author
  &amp;#40;:require &amp;#91;routes :refer &amp;#91;url-for&amp;#93;&amp;#93;
            &amp;#91;coast.validation :as v&amp;#93;
            &amp;#91;coast.error :refer &amp;#91;rescue&amp;#93;&amp;#93;
            &amp;#91;coast.responses :as res&amp;#93;
            &amp;#91;coast.db :as db&amp;#93;
            &amp;#91;buddy.hashers :as hashers&amp;#93;&amp;#41;&amp;#41;


&amp;#40;defn sign-up &amp;#91;req&amp;#93;
  &amp;#91;:div
    &amp;#40;form-for ::create
      &amp;#91;:label {:for &amp;quot;author/nickname&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/nickname&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/email&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;email&amp;quot; :name &amp;quot;author/email&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/password&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;

      &amp;#91;:input {:type &amp;quot;submit&amp;quot; :value &amp;quot;Sign Up&amp;quot;}&amp;#93;&amp;#41;&amp;#93;&amp;#41;


&amp;#40;defn encrypt-password &amp;#91;m&amp;#93;
  &amp;#40;assoc m :author/password &amp;#40;hashers/derive &amp;#40;:password m&amp;#41;&amp;#41;&amp;#41;&amp;#41;


&amp;#40;defn create &amp;#91;req&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;author errors&amp;#93; &amp;#40;-&amp;gt; &amp;#40;:params req&amp;#41;
                            &amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
                                         &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
                                          &amp;quot;dont match&amp;quot;&amp;#93;
                                         &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
                            &amp;#40;encrypt-password&amp;#41;
                            &amp;#40;dissoc ::password-confirmation&amp;#41;
                            &amp;#40;db/transact&amp;#41;
                            &amp;#40;rescue&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;nil? errors&amp;#41;
      &amp;#40;-&amp;gt; &amp;#40;res/redirect &amp;#40;url-for :home/index&amp;#41;&amp;#41;
          &amp;#40;res/flash &amp;quot;Welcome to bloggg!&amp;quot;&amp;#41;&amp;#41;
      &amp;#40;views.author/new &amp;#40;merge req errors&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Alright, so this is kind of a lot of stuff. It's overwhelming, no doubt. You have to start somewhere, might as well start here. Here's the breakdown:&lt;/p&gt;&lt;p&gt;The first &lt;code&gt;ns&lt;/code&gt; part is kind of a mess vs something like rails where you don't have to require anything and you have the whole framework available at your fingertips. I'm still working on this, not quite sure how to make something similar yet...&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns controllers.author
  &amp;#40;:require &amp;#91;routes :refer &amp;#91;url-for&amp;#93;&amp;#93;
            &amp;#91;coast.validation :as v&amp;#93;
            &amp;#91;coast.error :refer &amp;#91;rescue&amp;#93;&amp;#93;
            &amp;#91;coast.responses :as res&amp;#93;
            &amp;#91;coast.db :as db&amp;#93;
            &amp;#91;buddy.hashers :as hashers&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We want &lt;code&gt;url-for&lt;/code&gt; because referring to routes by name is so much cooler than strings. For this particular piece, we're encrypting a password, so we'll need &lt;code&gt;buddy.hashers&lt;/code&gt;, we'll also be recovering from business logic errors so we need &lt;code&gt;coast.error&lt;/code&gt; for &lt;code&gt;raise&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; which I'm going to talk more about soon. Also redirecting on form submit so add in &lt;code&gt;coast.responses&lt;/code&gt; and we'll be saving the params to the db after running it through a few functions, so here comes &lt;code&gt;coast.db&lt;/code&gt;.&lt;/p&gt;&lt;h2&gt;HTML (a.ka. Views)&lt;/h2&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn sign-up &amp;#91;req&amp;#93;
  &amp;#91;:div
    &amp;#40;form-for ::create
      &amp;#91;:label {:for &amp;quot;author/nickname&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/nickname&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/email&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;email&amp;quot; :name &amp;quot;author/email&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/password&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;

      &amp;#91;:input {:type &amp;quot;submit&amp;quot; :value &amp;quot;Sign Up&amp;quot;}&amp;#93;&amp;#41;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's time to talk about &lt;code&gt;form-for&lt;/code&gt;. Why not just use &lt;code&gt;&amp;#91;:form {:method &amp;quot;POST&amp;quot; :action &amp;quot;/sign-up&amp;quot;}&amp;#93;&lt;/code&gt;? Because! CSRF protection is built into coast, and in order for it work, you need to use the &lt;code&gt;form-for&lt;/code&gt; function from &lt;code&gt;components&lt;/code&gt;. Things like &lt;code&gt;url-for&lt;/code&gt; are nice to use with named routes because you already specified the html verb and url back in &lt;code&gt;routes.clj&lt;/code&gt; you don't need to do it again, unless you want to. This:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;form {:method :post :url &amp;quot;/sign-up&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and this&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;form-for ::create&amp;#41; ; or
&amp;#40;form-for :author/create&amp;#41; ; same thing because we're in &amp;#40;ns author&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;are the same thing, in fact &lt;code&gt;form-for&lt;/code&gt; is a &lt;strong&gt;pure&lt;/strong&gt; function &lt;i&gt;(FP alert)&lt;/i&gt; that is partially applied with routes and returns a map representing the http method and url for the given route name. Slick. 💫&lt;/p&gt;&lt;p&gt;One thing that is kind of awkward looking at this function is the mixing of hiccup with regular clojure functions. I am working on that, but stick with coast and this will get better with time.&lt;/p&gt;&lt;h2&gt;The Request&lt;/h2&gt;&lt;p&gt;Moving on from that next bit, let's tackle the actual function that gets called from the client, &lt;code&gt;create&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn create &amp;#91;req&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;author errors&amp;#93; &amp;#40;-&amp;gt; &amp;#40;:params req&amp;#41;
                            &amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
                                         &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
                                          &amp;quot;dont match&amp;quot;&amp;#93;
                                         &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
                            &amp;#40;encrypt-password&amp;#41;
                            &amp;#40;dissoc ::password-confirmation&amp;#41;
                            &amp;#40;db/transact&amp;#41;
                            &amp;#40;rescue&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;nil? errors&amp;#41;
      &amp;#40;-&amp;gt; &amp;#40;res/redirect &amp;#40;url-for :home/index&amp;#41;&amp;#41;
          &amp;#40;res/flash &amp;quot;Welcome to bloggg!&amp;quot;&amp;#41;&amp;#41;
      &amp;#40;sign-up &amp;#40;merge req errors&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first thing is that this function takes one argument, &lt;code&gt;req&lt;/code&gt; and here is what it looks like:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; the req argument
{:request-method :post
 :uri &amp;quot;/authors&amp;quot;
 :params {:author/nickname &amp;quot;&amp;quot;
          :author/email &amp;quot;&amp;quot;
          :author/password &amp;quot;&amp;quot;
          :author/password-confirmation &amp;quot;&amp;quot;
          :csrf-token &amp;quot;&amp;quot;}}
 ; ... there's a lot more stuff, but this is what we care about
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you're interested in knowing about the whole thing you can either &lt;code&gt;println&lt;/code&gt; it or &lt;a href='https://github.com/ring-clojure/ring/wiki/Concepts#requests'&gt;head over here and do some reading&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;So hopefully now it's clear what the rest of the code is doing:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Validate the values of those keys with &lt;code&gt;validate&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Encrypt the password with &lt;code&gt;encrypt-password&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Select only the keys we need for inserting into the db&lt;/li&gt;&lt;li&gt;Save our keys and values to the database with &lt;code&gt;db/transact&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Handle any validation or common database errors with &lt;code&gt;rescue&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The next thing that is really cool is the thread-first macro &lt;code&gt;-&amp;gt;&lt;/code&gt; this thing "threads" the first argument through each of the functions in the same set of parens &lt;code&gt;&amp;#40;&amp;#41;&lt;/code&gt;. &lt;code&gt;&amp;#40;:params req&amp;#41;&lt;/code&gt; does not get "threaded", that's just a normal key access function, getting the params out of the map from earlier.&lt;/p&gt;&lt;h2&gt;Validations&lt;/h2&gt;&lt;p&gt;The first function is the &lt;code&gt;v/validate&lt;/code&gt; function which is actually just a wrapper around &lt;a href='https://github.com/jkk/verily'&gt;this library&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;-&amp;gt; ;&amp;#40;:params req&amp;#41;
    &amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
                 &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
                  &amp;quot;dont match&amp;quot;&amp;#93;
                 &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
    ;&amp;#40;encrypt-password&amp;#41;
    ;&amp;#40;select-keys &amp;#91;::nickname ::email ::password&amp;#93;&amp;#41;
    ;&amp;#40;db/transact&amp;#41;
    ;&amp;#40;rescue&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is similar to something like rails where you define the validation with a class representing some database table. The next function is &lt;code&gt;encrypt-password&lt;/code&gt;.&lt;/p&gt;&lt;h2&gt;Encryption&lt;/h2&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn encrypt-password &amp;#91;m&amp;#93;
  &amp;#40;assoc m ::password &amp;#40;hashers/derive &amp;#40;::password m&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;-&amp;gt; ;&amp;#40;:params req&amp;#41;
    ;&amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
    ;             &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
    ;              &amp;quot;dont match&amp;quot;&amp;#93;
    ;             &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
    ;&amp;#40;encrypt-password&amp;#41;
    ;&amp;#40;select-keys &amp;#91;::nickname ::email ::password&amp;#93;&amp;#41;
    ;&amp;#40;db/transact&amp;#41;
    ;&amp;#40;rescue&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Parameter Whitelist&lt;/h2&gt;&lt;p&gt;After this thing is encrypted, we don't need the password-confirmation anymore, we only want &lt;code&gt;::nickname&lt;/code&gt;, &lt;code&gt;::email&lt;/code&gt; and &lt;code&gt;::password&lt;/code&gt;, so we select them with &lt;code&gt;select-keys&lt;/code&gt;. After that we &lt;em&gt;finally&lt;/em&gt; get to insert this data into the db with &lt;code&gt;transact&lt;/code&gt; and we handle any errors from &lt;code&gt;raise&lt;/code&gt; with &lt;code&gt;rescue&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;-&amp;gt; ;&amp;#40;:params req&amp;#41;
    ;&amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
    ;             &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
    ;              &amp;quot;dont match&amp;quot;&amp;#93;
    ;             &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
    ;&amp;#40;encrypt-password&amp;#41;
    &amp;#40;select-keys &amp;#91;::nickname ::email ::password&amp;#93;&amp;#41;
    ;&amp;#40;db/transact&amp;#41;
    ;&amp;#40;rescue&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Insert into the database&lt;/h2&gt;&lt;p&gt;At this point, we should have everything we need to insert into the database, and that's here&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;-&amp;gt; ;&amp;#40;:params req&amp;#41;
    ;&amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
    ;             &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
    ;              &amp;quot;dont match&amp;quot;&amp;#93;
    ;             &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
    ;&amp;#40;encrypt-password&amp;#41;
    ;&amp;#40;select-keys &amp;#91;::nickname ::email ::password&amp;#93;&amp;#41;
    &amp;#40;db/transact&amp;#41;
    ;&amp;#40;rescue&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;db/transact&lt;/code&gt; is really cool, it does an upsert so there's no need to worry about whether you're updating or inserting or what have you, just send it maps and you're good to go.&lt;/p&gt;&lt;h2&gt;Errors, Raise and Rescue&lt;/h2&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;let &amp;#91;&amp;#91;author errors&amp;#93; &amp;#40;-&amp;gt; &amp;#40;:params req&amp;#41;
                          &amp;#40;v/validate &amp;#91;&amp;#91;:required &amp;#91;::nickname ::email ::password&amp;#93;&amp;#93;
                                       &amp;#91;:equal &amp;#91;::password ::password-confirmation&amp;#93;
                                        &amp;quot;dont match&amp;quot;&amp;#93;
                                       &amp;#91;:min-length 12 ::password&amp;#93;&amp;#93;&amp;#41;
                          &amp;#40;encrypt-password&amp;#41;
                          &amp;#40;select-keys &amp;#91;::nickname ::email ::password&amp;#93;&amp;#41;
                          &amp;#40;db/transact&amp;#41;
                          &amp;#40;rescue&amp;#41;&amp;#41;
                      &amp;#93;&amp;#41;

; here's what errors looks like in the case of an empty ::nickname input

{:coast.errors/raise true
 :errors {:author/nickname &amp;quot;Nickname cannot be blank&amp;quot;}
 :coast.validation/error :validation}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;rescue&lt;/code&gt; is a macro that calls &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; on an argument that you pass it, it could be a function, or a series of functions, doesn't matter. It will &lt;code&gt;catch&lt;/code&gt; errors with &lt;code&gt;ex-info&lt;/code&gt; with a &lt;code&gt;{:coast.errors/raise true}&lt;/code&gt; key in them and return them as the second argument in that vector &lt;code&gt;&amp;#91;author errors&amp;#93;&lt;/code&gt;. It's kind of like a really naive &lt;code&gt;maybe&lt;/code&gt;. Coast has some built in error handling things around postgres not null and unique errors along with turning validation errors into a map like this &lt;code&gt;{:author/name &amp;quot;Name cannot be blank&amp;quot;}&lt;/code&gt;. You can customize the message similar to what you saw in the &lt;code&gt;validate&lt;/code&gt; function.&lt;/p&gt;&lt;p&gt;After all of that there is still some code! Doing the right thing on error or redirecting:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;if &amp;#40;nil? errors&amp;#41;
  &amp;#40;-&amp;gt; &amp;#40;res/redirect &amp;#40;url-for :home/index&amp;#41;&amp;#41;
      &amp;#40;res/flash &amp;quot;Welcome to bloggg!&amp;quot;&amp;#41;&amp;#41;
  &amp;#40;sign-up &amp;#40;merge req errors&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here if there are no errors, then it's time to redirect to the index page with a flash message and show the new post, which we haven't written anything for that yet, but we'll get there.&lt;/p&gt;&lt;p&gt;If there are errors, then we'll just show the new view again with an &lt;code&gt;:errors&lt;/code&gt; key and handle those errors in the form, like so:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn sign-up &amp;#91;req&amp;#93;
  &amp;#91;:div
    &amp;#40;form-for ::create
      &amp;#91;:div {:class &amp;quot;red&amp;quot;}&amp;#93;
        &amp;#40;-&amp;gt; req :errors :author/nickname&amp;#41;
      &amp;#91;:label {:for &amp;quot;author/nickname&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/nickname&amp;quot;}&amp;#93;

      &amp;#91;:div {:class &amp;quot;red&amp;quot;}&amp;#93;
        &amp;#40;-&amp;gt; req :errors :author/email&amp;#41;
      &amp;#91;:label {:for &amp;quot;author/email&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;email&amp;quot; :name &amp;quot;author/email&amp;quot;}&amp;#93;

      &amp;#91;:div {:class &amp;quot;red&amp;quot;}&amp;#93;
        &amp;#40;-&amp;gt; req :errors :author/password&amp;#41;
      &amp;#91;:label {:for &amp;quot;author/password&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password&amp;quot;}&amp;#93;

      &amp;#91;:label {:for &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;
      &amp;#91;:input {:type &amp;quot;text&amp;quot; :name &amp;quot;author/password-confirmation&amp;quot;}&amp;#93;

      &amp;#91;:input {:type &amp;quot;submit&amp;quot; :value &amp;quot;Sign Up&amp;quot;}&amp;#93;&amp;#41;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is such a common pattern, coast will soon abstract some of this away for you, but for right now, it's here in this tutorial.&lt;/p&gt;&lt;p&gt;Stay tuned for the next part where We make this thing a lot prettier and "componentize" some of the html elements...&lt;/p&gt;</content></entry><entry><title>coast.delta routing</title><updated>May 19 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/05-19-2018-coast-delta-routing.html"></link><id>urn:swlkr-com:feed:post:coast.delta routing</id><content type="html">&lt;p&gt;It's remained pretty much the same, except for support for named routes! Finally! Two things had to happen, one, I had to start referring to routes by symbol instead of directly by function due to a circular reference error and two, I had to change most of the user facing api code, &lt;a href='https://www.youtube.com/watch?v=Gzj723LkRJY'&gt;woops&lt;/a&gt;. Here's what it looks like.&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; `controllers.home/index :home&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That last element in the vector is the name. If you don't give it a name, it defaults to the keyword version of the symbol you give it, so in this case it would be :controllers.home/index.&lt;/p&gt;&lt;p&gt;Here's how you look up routes by name&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns routes
  &amp;#40;:require &amp;#91;coast.router :as router&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; `controllers.home/index :home&amp;#93;
             &amp;#91;:get &amp;quot;/items/:id&amp;quot; `controllers.items/show :items/show&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def url-for &amp;#40;router/url-for-routes routes&amp;#41;&amp;#41;

&amp;#40;url-for :home&amp;#41; ; =&amp;gt; &amp;quot;/&amp;quot;

&amp;#40;url-for :items/show {:id 1}&amp;#41; ; =&amp;gt; &amp;quot;/items/1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Forms&lt;/h2&gt;&lt;p&gt;There's also a little something for forms which I never liked before, but now I do&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; routes.clj
&amp;#40;ns routes
  &amp;#40;:require &amp;#91;coast.router :as router&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; `controllers.home/index :home&amp;#93;
             &amp;#91;:post &amp;quot;/&amp;quot; `controllers.home/create :create&amp;#93;
             &amp;#91;:put &amp;quot;/:id&amp;quot; `controllers.home/update :update&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def url-for &amp;#40;router/url-for-routes routes&amp;#41;&amp;#41;
&amp;#40;def action-for &amp;#40;router/action-for-routes routes&amp;#41;&amp;#41;

; views/home.clj
&amp;#40;ns views.home
  &amp;#40;:require &amp;#91;routes :refer &amp;#91;action-for&amp;#93;&amp;#93;
            &amp;#91;coast.components :refer &amp;#91;form&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn index &amp;#91;request&amp;#93;
  &amp;#40;form &amp;#40;action-for :create&amp;#41;&amp;#41;&amp;#41; ; =&amp;gt; &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;/&amp;quot;&amp;gt;

&amp;#40;defn edit &amp;#91;request&amp;#93;
  &amp;#40;form &amp;#40;action-for :update {:id 123}&amp;#41;&amp;#41;&amp;#41; ; =&amp;gt; &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;/123?&amp;#95;method=put&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I really love this routing with coast and it probably won't change again, it's data, they're named, it's simple and it's beautiful. Hope you like it too. If you're curious about coast and want to give it a shot and you're stuck, send me an email or DM me on twitter any time!&lt;/p&gt;</content></entry><entry><title>I made my first $1 from my side projects in just 9 short years 💪</title><updated>April 22 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-22-2018-how-i-made-my-first-dollar.html"></link><id>urn:swlkr-com:feed:post:I made my first $1 from my side projects in just 9 short years 💪</id><content type="html">&lt;p&gt;I’ve been making websites in earnest for 9 years now and I’m excited to report, I’ve just made my first dollar on the internet. How did I do it, why did it take me so long? Sit back, relax and let me tell you a maker’s tale of misery and woe.&lt;/p&gt;&lt;p&gt;&lt;img src="https://cdn-images-1.medium.com/max/1600/1*8yl4jZ4CUxBWwIpr3i8bbQ@2x.jpeg" alt="" /&gt;&lt;/p&gt;&lt;h2&gt;The “I’m bad at this” years&lt;/h2&gt;&lt;p&gt;I’m not sure when I could finally make a decent website, but I can tell you when I couldn’t and that was when I first started. The problem with not being able to make websites very well isn’t really a problem of design or programming, it’s a problem of confidence. I would have an idea in my head and I would jam it out, but as I kept writing code for months and months, two things would happen. The idea in my head would never show up on the screen. In fact what I kept seeing on the screen was a pile of hot garbage in comparison. The second thing that would happen is that I would lose motivation and quit the project altogether without even telling anyone. This is the worst outcome for a side project, it demotivates you to even try again and it also means other than gaining programming/design experience, which is good, you just lost the opportunity to show someone something that although is rough, might just be useful to more than just you. This spiral of making something, not being proud of it, giving up, not telling anyone, and getting demotivated went on for quite a while before I made a change.&lt;/p&gt;&lt;h2&gt;The “I’m bad at this, but I also want this so bad, I’m going to just put things out there” years&lt;/h2&gt;&lt;p&gt;After I started to get less bad at things where if I squinted right and ignored a few of the glaring design flaws and the lack of polish, I could at least share what I’ve made. Of course these were also the years where I wasn’t putting enough time/effort into marketing, that’s still a problem I’m dealing with today, but at least I have the wherewithal to share the link in different places. I put out a lot of different websites trying to find something that was useful to me and useful to other people as well. These were the grind years, the years where I was trying to find the will and the motivation and a technique to finish my projects within the time constraints of a full time job and a full time life. I got married during these years, I bought my first house, I got a dog. I started traveling a lot more internationally. I was finally living life.&lt;/p&gt;&lt;h2&gt;The “I’m actually ok at this, but I need to get better in other areas” years&lt;/h2&gt;&lt;p&gt;A few years ago, I finally found the programming language that just clicked for me and my websites, it’s a little weird and a little esoteric, just like me. After I finally found something I loved to do every day, I got to work, but work on side projects wasn’t just like my day job programming for 8 hours with meetings here and there, it was more than that, it was marketing, it was selling. And to this day it still is. Once I found my one true language, it turned out not to matter, it’s nice to love the thing that makes the things people love, but it’s not what is going to make you that first $1. The thing that made me my first dollar was getting over myself, and getting over my fear of of what other people thought. My first dollar was made through a year plus of blogging in the open about my projects, and a semi-successful launch on places like &lt;a href='https://producthunt.com'&gt;product hunt&lt;/a&gt;. I may not have gotten to #1 that day, but I did get retweeted on the PH twitter, which was huge. When you’re small like me, existing platforms are the way to that first $1.&lt;/p&gt;&lt;h2&gt;Where do I go from here?&lt;/h2&gt;&lt;p&gt;Well, I just to have to market and sell directly even more and code even less. I’ve started a 12 startups in 12 month challenge, where I make 12 websites (or versions of those websites) and see if anyone wants them. There’s something scary about the unknown and about a life of side projects beyond programming, but I’ve finally reached the point where I don’t care if I have to drag myself kicking and screaming up the mountain of shameless self promotion, I will reach the summit. Never give up, never surrender. Keep shipping my friends.&lt;/p&gt;</content></entry><entry><title>All your ppl</title><updated>April 19 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-19-2018-all-your-ppl.html"></link><id>urn:swlkr-com:feed:post:All your ppl</id><content type="html">&lt;p&gt;The idea for &lt;a href='http://allyourppl.com'&gt;all your ppl&lt;/a&gt; came from my frustration watching my wife, and my friends continue to use this garbage, mega-corp software to communicate with their friends. Ads everywhere, &lt;a href='https://www.nytimes.com/2014/06/30/technology/facebook-tinkers-with-users-emotions-in-news-feed-experiment-stirring-outcry.html'&gt;psychological manipulation&lt;/a&gt;, everything you ever upload doesn't belong to you, it belongs to the corporation and whoever else pays for that data.&lt;/p&gt;&lt;h2&gt;Ads everywhere&lt;/h2&gt;&lt;p&gt;Ads aren't even the problem really, the problem is the hyper targeting of you as a person. Did you click something interesting the other day? Well a tracking cookie followed you or if a tracking cookie didn't follow you, facebook or whoever was tracking your IP address so now they know you're interested in that thing, EVEN IF IT WASNT ON FACEBOOK. Ads by themselves are harmless when they are displayed unobtrusively, explicitly and without all of the knowledge of every one of your past "likes". Ads should work like this, advertiser wants to advertise to all your ppl, ad goes up, the servers keep running, bills get paid, ad comes down. No targeting, no ads in your feed, none of that nonsense.&lt;/p&gt;&lt;h2&gt;Psychological manipulation&lt;/h2&gt;&lt;p&gt;Even if you don't care about the ads and you're just glad this stuff is free, the &lt;em&gt;real&lt;/em&gt; problem with ads like the ones on large social media services today is that in order to keep you coming back to see more and more ads, they want to addict you to the service. Algorithmic feeds, red notification icons, every time you open the app, the thing is different with new content. It keeps you interested and instead of opening the app once a day or even twice a day, you might open it once or twice an hour. All those quick 1-2 minute dopamine hits don't seem like much at first, but over the course of a given week they add up to lost time to do other things, like exercise, think critically about your future and how your life is going, these companies and these social media services rob you of time to think for yourself, and that's exactly what they want. The more time you spend on their service, the more money they make from advertisers.&lt;/p&gt;&lt;h2&gt;Growth at all costs&lt;/h2&gt;&lt;p&gt;Well, why don't they just chill out and stop employing all of these tricks to keep you coming back? Because, they have a duty to the shareholders, and apparently to themselves to not just be ok with &lt;a href='https://m.signalvnoise.com/enough-1d48019c7335'&gt;enough&lt;/a&gt; but to TAKE OVER THE WHOLE WORLD. &lt;a href='https://a16z.com/2016/08/20/why-software-is-eating-the-world/'&gt;Software is eating the world&lt;/a&gt; they say, and they're right. It's not only eating into the real world, it's eating into our minds. So yes, these large tech corporations like twitter, facebook, and google, need to keep you coming back and they won't be satisfied until every single human soul on planet earth is using their services as much as humanly possible every waking second of every waking day, because "if you aren't growing, you're dying."&lt;/p&gt;&lt;h2&gt;What can one person do?&lt;/h2&gt;&lt;p&gt;Can I make a difference with a clone of popular social networks? Maybe, it's worth a shot. Sometimes the dumbest ideas work out.&lt;/p&gt;</content></entry><entry><title>Reinventing the wheel with a clojure static site generator</title><updated>April 16 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-16-2018-reinventing-the-wheel-static-site-generator.html"></link><id>urn:swlkr-com:feed:post:Reinventing the wheel with a clojure static site generator</id><content type="html">&lt;p&gt;There's probably nothing I love more in this world than coming up with my own solution to an already solved problem. People call it yak shaving, re-inventing the wheel, what have you, I love it. My latest re-invention is a just-for-me static site generator. It turns markdown files in a folder into html pages fit for reading. There are a few parts to any static site generator, the first of which is file/folder organization.&lt;/p&gt;&lt;h2&gt;Organization&lt;/h2&gt;&lt;p&gt;In the root of the project is the index.html, css and javascript files which I started hand-editing just like the good old days. After a few different blog posts, things started to get a little out of hand, I started to make mistakes trying to copy/paste headers/footers. So I decided to make my own static site generator in about 100 lines of clojure. The first thing is that I had to separate where the clojure and html "templates" or really just placeholders for the real generated html would go. I decided on src for clojure code and templates and /posts for the generated html files for posts and to keep everything else in the top level folder. That was that. Now I only had to worry about converting markdown to html and gluing it together with html "layout" files or shared bits of html like the header/footer and css/js file references.&lt;/p&gt;&lt;h2&gt;Code structure&lt;/h2&gt;&lt;p&gt;The clojure compiler is "single pass" meaning you can't reference a function until you define it, so all clojure code works from the bottom of the file to the top. To find out where the top is you have to look at the bottom. Classic clojure simplicity. The main idea of the generator is to &lt;code&gt;slurp&lt;/code&gt; up markdown and html files in &lt;code&gt;/src/posts&lt;/code&gt;, turn them into a clojure hash map (or dictionary) as all html, then &lt;code&gt;spit&lt;/code&gt; them into &lt;code&gt;/posts&lt;/code&gt;. Here's the first part of that:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn replacement &amp;#91;match m&amp;#93;
  &amp;#40;let &amp;#91;fallback &amp;#40;first match&amp;#41;
        k &amp;#40;-&amp;gt; match last keyword&amp;#41;&amp;#93;
    &amp;#40;str &amp;#40;get m k fallback&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn fill &amp;#91;m s&amp;#93;
  &amp;#40;string/replace s #&amp;quot;&amp;#95;&amp;#95;&amp;#40;&amp;#91;\w-&amp;#93;+&amp;#41;&amp;#95;&amp;#95;&amp;quot; #&amp;#40;replacement % m&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two functions are really the meat and potatoes of this whole thing, the CRUX of what I'm talking about. These two functions fill in blanks that &lt;b&gt;look-like-this&lt;/b&gt; with any variable in a given clojure hash map. It works like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;fill {:name &amp;quot;sean&amp;quot;} &amp;quot;hello &amp;#95;&amp;#95;name&amp;#95;&amp;#95;&amp;quot;&amp;#41; ; =&amp;gt; &amp;quot;hello sean&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not super impressive by itself, it's downright boring, but when you start getting the strings from files, it becomes a templating function:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn front-matter &amp;#91;k s&amp;#93;
  &amp;#40;some-&amp;gt; &amp;#40;re-pattern &amp;#40;format &amp;quot;%s:&amp;#40;.+&amp;#41;&amp;quot; &amp;#40;name &amp;#40;or k :nothing&amp;#41;&amp;#41;&amp;#41;&amp;#41;
          &amp;#40;re-find s&amp;#41;
          &amp;#40;second&amp;#41;
          &amp;#40;string/trim&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def title &amp;#40;partial front-matter :title&amp;#41;&amp;#41;
&amp;#40;def date &amp;#40;partial front-matter :date&amp;#41;&amp;#41;
&amp;#40;def preview &amp;#40;partial front-matter :preview&amp;#41;&amp;#41;

&amp;#40;defn post &amp;#91;filename&amp;#93;
  &amp;#40;let &amp;#91;filepath &amp;#40;format &amp;quot;src/posts/%s&amp;quot; filename&amp;#41;
        s &amp;#40;slurp filepath&amp;#41;
        preview &amp;#40;-&amp;gt; &amp;#40;preview s&amp;#41;
                    &amp;#40;md/md-to-html-string&amp;#41;&amp;#41;
        title &amp;#40;title s&amp;#41;
        date &amp;#40;date s&amp;#41;
        markdown &amp;#40;drop-front-matter s&amp;#41;
        content &amp;#40;md/md-to-html-string markdown&amp;#41;
        url &amp;#40;format &amp;quot;posts/%s&amp;quot; &amp;#40;string/replace filename #&amp;quot;.md&amp;quot; &amp;quot;.html&amp;quot;&amp;#41;&amp;#41;&amp;#93;
    {:title title
     :date date
     :url url
     :markdown markdown
     :content content
     :preview preview}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So ignoring the markdown frontmatter stuff, this is how a given post gets rendered into html from markdown and a given html template, here it's a map to make the next step easier:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn render-post-preview &amp;#91;post&amp;#93;
  &amp;#40;let &amp;#91;layout &amp;#40;slurp &amp;quot;src/posts/post.html&amp;quot;&amp;#41;&amp;#93;
    &amp;#40;fill post layout&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn render-post &amp;#91;post&amp;#93;
  &amp;#40;let &amp;#91;layout &amp;#40;slurp &amp;quot;src/posts/layout.html&amp;quot;&amp;#41;
        post-html &amp;#40;fill post layout&amp;#41;
        html &amp;#40;fill {:content post-html
                    :relative &amp;quot;../&amp;quot;} &amp;#40;slurp &amp;quot;src/layout.html&amp;quot;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;spit &amp;#40;:url post&amp;#41; html&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two functions render a small preview on the index page and an actual post. Since I don't have to worry about anyone else using this thing, I can just hard code the paths where the html templates are, and I did. Software is so easy when you're the only user.&lt;/p&gt;&lt;h2&gt;The end&lt;/h2&gt;&lt;p&gt;So in the end, I've reinvented the wheel, and had a lot of fun doing it. The next time someone says that some piece of software already exists, ignore them immediately and do what you want to do, TREAT YOURSELF to some new code and maybe come up with a better way to do something! If you're curious, the whole thing is &lt;a href='https://gist.github.com/swlkr/65e68ad068d461767bbf78591f3415c4'&gt;here in a gist&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>coast on clojure</title><updated>April 10 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-10-2018-coast.html"></link><id>urn:swlkr-com:feed:post:coast on clojure</id><content type="html">&lt;h1&gt;Who is behind coast on clojure?&lt;/h1&gt;&lt;p&gt;Hey, I'm Sean 👋, I like writing clojure and making websites &lt;em&gt;quickly&lt;/em&gt; and easily. I've been making websites for about 20 years now, and I've gone through quite a few different frameworks, libraries and the like to know what suits me and maybe what suits you too!&lt;/p&gt;&lt;p&gt;When I'm not programming, I like to try and promote my websites around the internet, I also like to get outdoors often with my wife and my dog. I also play a mean game of settlers of catan.&lt;/p&gt;&lt;h1&gt;What is coast on clojure?&lt;/h1&gt;&lt;p&gt;Coast on clojure is a rails-inspired "full stack web framework" for making websites, or if you don't want to be fancy, it's a bunch of clojure code that helps you make websites.&lt;/p&gt;&lt;p&gt;I say websites, not web apps, because I think there's a lot of confusion over what makes something a web app vs a site. Heavy use of javascript frameworks come to mind when talking about web apps, which is something I don't really find to be terribly useful when you make websites as a one man band.&lt;/p&gt;&lt;p&gt;So coast focuses on ease of use above all else. When you're making websites with coast and it isn't easy or obvious on how to proceed, go ahead and send an issue my way, and I'll probably push it to master right away!&lt;/p&gt;&lt;h1&gt;Why coast on clojure?&lt;/h1&gt;&lt;p&gt;You should choose coast on clojure if you like clojure and you like making websites.&lt;/p&gt;&lt;p&gt;Coast gives you a bunch of things that you normally wind up putting together yourself after a lot of searching, trying and failing. Integrating different libraries is really not something I wanted to spend my time on and I don't think you want to either. Let's say you want background jobs, you can look at the existing clojure background job libraries or use a language agnostic one, but you're already spending time not making your websites. That's not good! Use coast and jobs are built in, open your terminal in a folder with a coast app and type&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;coast gen jobs
make db/migrate
mkdir jobs
touch jobs/emails.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Edit &lt;code&gt;jobs/emails.clj&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns jobs.emails
  &amp;#40;:require &amp;#91;coast.jobs&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn send &amp;#91;email&amp;#93;
  &amp;#40;mailgun/send email&amp;#41;&amp;#41; ; or whatever you use for email

&amp;#40;defn queue &amp;#91;email&amp;#93;
  &amp;#40;coast.jobs/queue #'send email&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BOOM. You have a job that emails that you can use like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;require '&amp;#91;jobs.emails&amp;#93;&amp;#41;

&amp;#40;jobs.emails/queue {:to &amp;quot;you@you.com&amp;quot; :from &amp;quot;me@me.com&amp;quot; :subject &amp;quot;subject&amp;quot; :body &amp;quot;body&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Coast also has it's own built in worker that is currently pretty naive but can be started up with &lt;code&gt;clj -m coast.worker&lt;/code&gt;&lt;/p&gt;&lt;p&gt;This guy emails!&lt;/p&gt;&lt;h1&gt;Getting started with coast on clojure&lt;/h1&gt;&lt;p&gt;Starting with coast on clojure is pretty easy, but I'm always open to suggestions.&lt;/p&gt;&lt;p&gt;Here's how you can start a simple web server with coast right now:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;mkdir -p proj proj/src
touch proj/deps.edn
touch proj/src/server.clj
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; deps.edn
{:paths &amp;#91;&amp;quot;src&amp;quot;&amp;#93;
 :deps {coast.gamma {:git/url &amp;quot;https://github.com/swlkr/coast&amp;quot;
                     :sha &amp;quot;5242b6dcf6ca77b57de5b77f4dd47516ce459eff&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; src/server.clj
&amp;#40;ns server
  &amp;#40;:require &amp;#91;coast.gamma :as coast&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn hello &amp;#91;request&amp;#93;
  {:status 200
   :headers {&amp;quot;Content-Type&amp;quot; &amp;quot;text/html&amp;quot;}
   :body &amp;#40;str &amp;quot;hello &amp;quot; &amp;#40;-&amp;gt; request :params :name&amp;#41;&amp;#41;}&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/hello/:name&amp;quot; hello&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def app &amp;#40;coast/app routes&amp;#41;&amp;#41;

&amp;#40;coast/start-server app&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then in your terminal, run:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;clj src/server.clj &amp;amp;
# you should see =&amp;gt; server is listening on port 1337
curl localhost:1337/hello/world
# you should see =&amp;gt; hello world
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are so many nice little things in coast, I'm still taking the time to document them all, but rest assured, document them I will. I also improve the thing every month I make a new website, hopefully one of these days I'll nail the public facing api down and make one version that is backwards compatible until the end of time!&lt;/p&gt;&lt;p&gt;Stay tuned for more posts about coast!&lt;/p&gt;</content></entry><entry><title>rss feeds</title><updated>April 05 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-05-2018-rss-feeds.html"></link><id>urn:swlkr-com:feed:post:rss feeds</id><content type="html">&lt;h1&gt;Where we were before&lt;/h1&gt;&lt;p&gt;I'm getting pretty old now in internet time, I've been browsing the web almost every day (which is sad in retrospect) for the better part of 20 years. I've seen it go from a niche hobby with people making personal websites and blogs, to what it is today, a mostly corporately owned, watered down version of itself, but even that isn't new, AOL was the first company to water the internet down and make it easy for everyone to get online. The internet is still amazing and equal parts scary and weird, just like how it was 20 years ago, except now the trendy designs and corporations are getting really good, whereas before you could largely ignore AOL because it was hopelessly bad.&lt;/p&gt;&lt;h1&gt;Where we are now&lt;/h1&gt;&lt;p&gt;Which kind of leads us to where we are today in 2018, to no one's surprise, the walled gardens aren't looking as enticing as they were before, this time it's not an "unfiltered" internet or faster speeds that's going to make a dent in people's perception of the giants, it's privacy, LIBERTY, and control over one's own mind.&lt;/p&gt;&lt;p&gt;Heavy stuff. I'm going to bring back the word heavy, such a good word.&lt;/p&gt;&lt;p&gt;So assuming people do care about their time, and their thoughts, how can we all keep up with the things we love online without a massive corporation running machine learning algorithms to show us content? RSS feeds.&lt;/p&gt;&lt;h1&gt;Where do RSS feeds fit in?&lt;/h1&gt;&lt;p&gt;RSS feeds were huge in the early-mid turn of the century (2000s) but subsequently died with the rise of social media, which is sad because being in control of the content you saw was really great, and there was no intermediary between you and the content creator, no middleman, the middleman was automated away with a single file hosted on people's web servers: &lt;code&gt;atom.xml&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I have to give credit where it's due though, discovery of that &lt;code&gt;atom.xml&lt;/code&gt; file even now hasn't quite been solved as nicely as it was on social media, with &lt;code&gt;#&lt;/code&gt; hashtags and &lt;code&gt;@&lt;/code&gt; mentions, and it's definitely not easy or free to get started with your own website even today. Buying a domain is a pain in the butt and costs $10/year.&lt;/p&gt;&lt;p&gt;You could argue that social media is a nicer, more user friendly layer on top of the existing internet, instead of web servers, web sites and links, that all got abstracted away into a few large databases, feeds, mentions and hashtags. It's pretty impressive looking at it now, so much easier to get started writing/reading/viewing online than it still is with traditional websites and links today. Blogs were popular, but they're daunting,  seen now only as a means to an end: "Maybe if I start a blog, I can put ads on it and make some money". It would be nice to give people control over their content and even monetize it themselves instead of feeding everything to machine learning algorithms for free. A few aspects that make social media less cumbersome than starting your own website are:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Email + Username/password to get started for free&lt;/li&gt;&lt;li&gt;Limited set of things to fill in, bio (profile), maybe gender, maybe age/birthday, maybe a link to an external website&lt;/li&gt;&lt;li&gt;Shown a list of friends/connections already online, start following&lt;/li&gt;&lt;li&gt;Limited set of things needed to start, upload a picture or a little blob of text (&lt; 240 characters), BAM it's in the "feed"&lt;/li&gt;&lt;li&gt;Concept of a global feed (twitter moments/instagram explore)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The idea that you can essentially create a webpage/mobile app presence with just your email, a name and a password is pretty great, you've just traded 5 minutes (maybe) of your time and all of a sudden anyone in the world can find you at &lt;code&gt;huge-tech-company.com/you&lt;/code&gt;. Pretty cool. Of course as you start to try and use this thing, a few things become not so nice about the experience, you see your first ad, and if you're on a mobile app, you can't block them, so that stinks, I guess nothing's really free after all.&lt;/p&gt;&lt;h1&gt;The move back to an "open" and "not so free" web&lt;/h1&gt;&lt;p&gt;Decentralization gets brought up a lot usually in tandem with blockchains or something, but the web save dns is already pretty decentralized, if it was easier for people to have their own domain and their own rss feeds, we might take a chunk of business away from huge tech corps, which at this point is a really good thing.&lt;/p&gt;&lt;p&gt;If you're interested in following updates on this blog, subscribe here: &lt;a href='http://swlkr.com/rss.xml'&gt;http://swlkr.com/rss.xml&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>making websites with clojure</title><updated>April 03 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/04-03-2018-making-websites-with-clojure.html"></link><id>urn:swlkr-com:feed:post:making websites with clojure</id><content type="html">&lt;p&gt;In the clojure world making websites is simple, like tropic thunder simple jack simple. There's one function that handles every request and every response and it's made up of a bunch of other functions and they all operate on the same data structure, a clojure map representing an http request and that one function returns a response which is another clojure map.&lt;/p&gt;&lt;p&gt;It looks like this:&lt;/p&gt;&lt;p&gt;request -&gt; function -&gt; response&lt;/p&gt;&lt;p&gt;or like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn handler &amp;#91;request&amp;#93;
  &amp;#40;if &amp;#40;and &amp;#40;= &amp;#40;:uri request&amp;#41; &amp;quot;/&amp;quot;&amp;#41;
           &amp;#40;= &amp;#40;:request-method request&amp;#41; :get&amp;#41;&amp;#41;
    {:status 200
     :headers {&amp;quot;Content-Type&amp;quot; &amp;quot;text/html&amp;quot;}
     :body &amp;quot;hello, world!&amp;quot;}
    {:status 404
     :headers {&amp;quot;Content-Type&amp;quot; &amp;quot;text/html&amp;quot;}
     :body &amp;quot;not found&amp;quot;}&amp;#41;&amp;#41;

&amp;#40;handler {:uri &amp;quot;/&amp;quot; :request-method :get}&amp;#41; ; =&amp;gt; {:status 200 ...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That's it! This simple concept is almost too simple, like it can't be that simple or that easy. There's got to be a catch how can you make a whole website with authentication and emailing and credit card handling and social features and... from just one function?&lt;/p&gt;&lt;p&gt;Well, I'm glad you asked! The first thing that I should tell you is that there's going to be quite a few more functions, but if you can imagine them all sort of coming together to be one function, it makes it easier to think about. The second thing is I need to quote &lt;em&gt;the quote&lt;/em&gt; about how it's better to have 100 function operating on 1 data structure than 10 functions operating on 10 data structures or something.&lt;/p&gt;&lt;p&gt;Anyway, to get a more complete app you first need to pass functions to other functions, instead of just the request map, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn middleware &amp;#91;handler&amp;#93;
  &amp;#40;fn &amp;#91;request&amp;#93;
    &amp;#40;handler request&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So now you can chain these functions together and still have "one function".&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn home &amp;#91;request&amp;#93;
  {:status 200
   :body &amp;quot;home&amp;quot;}&amp;#41;

&amp;#40;defn sign-in &amp;#91;request&amp;#93;
  {:status 200
   :body &amp;quot;sign-in&amp;quot;}&amp;#41;

&amp;#40;defn first-handler &amp;#91;&amp;#93;
  &amp;#40;fn &amp;#91;request&amp;#93;
    &amp;#40;let &amp;#91;{:keys &amp;#91;uri request-method&amp;#93;} request&amp;#93;
      &amp;#40;case
        &amp;#40;= uri &amp;quot;/&amp;quot;&amp;#41; &amp;#40;home request&amp;#41;
        &amp;#40;= uri &amp;quot;/sign-in&amp;quot;&amp;#41; &amp;#40;sign-in request&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn logger &amp;#91;handler&amp;#93;
  &amp;#40;fn &amp;#91;request&amp;#93;
    &amp;#40;let &amp;#91;response &amp;#40;handler request&amp;#41;&amp;#93;
      &amp;#40;println &amp;#40;:request-method request&amp;#41; &amp;#40;:uri request&amp;#41;&amp;#41;
      response&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def app &amp;#40;-&amp;gt; &amp;#40;first-handler&amp;#41;
             &amp;#40;logger&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Things are still looking ugly, but it gets better with coast on clojure :)&lt;/p&gt;&lt;p&gt;Still working on a that whole series of posts going deep, so stay tuned or just &lt;a href='https://github.com/coast-framework/coast'&gt;check out it and spoil the surprise&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>coast.beta: an easy way to make websites with clojure</title><updated>March 18 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/03-18-2018-coast-beta.html"></link><id>urn:swlkr-com:feed:post:coast.beta: an easy way to make websites with clojure</id><content type="html">&lt;p&gt;When it’s time to make a website, what do you really want? You want to associate a url with a bit of code. &lt;del&gt;You don’t want route files and&lt;/del&gt; you don’t want to be googling dependencies left and right, you want to stand up a website in as few lines of code as possible, the closer to zero code you can get, the better. That’s what the goal of coast.beta is, you can generate crud websites from the command line, living the dream.&lt;/p&gt;&lt;h2&gt;Routing&lt;/h2&gt;&lt;p&gt;This is a route&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#91;:get &amp;quot;/&amp;quot; home&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is a route in coast&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn hello &amp;#91;request&amp;#93;
  &amp;#91;:div &amp;quot;hello world!&amp;quot;&amp;#93;&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; hello&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def app &amp;#40;coast/app routes&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Routes in coast are a vector of vectors, the routes that are on top get matched first&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn hello &amp;#91;request&amp;#93;
  &amp;#91;:div &amp;quot;hello world!&amp;quot;&amp;#93;&amp;#41;

&amp;#40;defn goodbye &amp;#91;request&amp;#93;
  &amp;#91;:div &amp;quot;goodbye, cruel world!&amp;quot;&amp;#93;&amp;#41;

&amp;#40;def routes &amp;#91;&amp;#91;:get &amp;quot;/&amp;quot; hello&amp;#93;
             &amp;#91;:get &amp;quot;/&amp;quot; goodbye&amp;#93;&amp;#93;&amp;#41;

&amp;#40;def app &amp;#40;coast/app routes&amp;#41;&amp;#41;

&amp;#40;app {:request-method :get :uri &amp;quot;/&amp;quot;}&amp;#41; ; =&amp;gt; &amp;lt;div&amp;gt;hello world!&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here's a more complete example for something like auth with &lt;a href='https://funcool.github.io/buddy-auth/latest/'&gt;buddy&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns routes
  &amp;#40;:require &amp;#91;coast.router :refer &amp;#91;get post put delete wrap-routes&amp;#93;&amp;#93;
            &amp;#91;controllers.home :as c.home&amp;#93;
            &amp;#91;controllers.users :as c.users&amp;#93;
            &amp;#91;buddy.auth&amp;#93;&amp;#41;
  &amp;#40;:refer-clojure :exclude &amp;#91;get&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn wrap-auth &amp;#91;handler&amp;#93;
  &amp;#40;fn &amp;#91;request&amp;#93;
    &amp;#40;if &amp;#40;buddy.auth/authenticated? request&amp;#41;
      &amp;#40;handler request&amp;#41;
      &amp;#40;coast.responses/forbidden
        &amp;#91;:div &amp;quot;I'm sorry dave, I can't let you do that.&amp;quot;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def auth &amp;#40;-&amp;gt; &amp;#40;get &amp;quot;/users/:id&amp;quot; c.users/show&amp;#41;
  &amp;#40;wrap-routes middleware/wrap-auth&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def public &amp;#40;get &amp;quot;/&amp;quot; c.home/index&amp;#41;&amp;#41;

&amp;#40;def routes &amp;#40;concat public auth&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Models&lt;/h2&gt;&lt;p&gt;Since clojure doesn’t have objects, there isn't an ORM. Prepare yourself for the raw, awesome power of SQL. Similar to the way you want to tie a url to function that emits html, you also want to tie a function to a bit of SQL on the other end. There are other ways to do this, but the best way I’ve found is instead of trying to treat SQL like a data structure or use another DSL that’s missing joins or something, just use SQL. Here’s a SQL file with comments&lt;/p&gt;&lt;pre&gt;&lt;code class="sql"&gt;-- resources/sql/posts.db.sql
-- name: list
select &amp;#42;
from posts
order by created&amp;#95;at
offset :offset
limit :limit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here a clojure function with the same name as the name in the sql comments.&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns db.posts
  &amp;#40;:require &amp;#91;coast.db :refer &amp;#91;defq&amp;#93;&amp;#41;
  &amp;#40;:refer-clojure :exclude &amp;#91;list&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defq list &amp;quot;/resources/sql/posts.sql&amp;quot;&amp;#41;

&amp;#40;list {:offset 0 :limit 10}&amp;#41; ; =&amp;gt; &amp;#91;{:id 1 :title &amp;quot;&amp;quot; :body &amp;quot;&amp;quot;}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When you call that function, you get data. It seems like there’s something missing, but there isn’t.&lt;/p&gt;&lt;h2&gt;Views&lt;/h2&gt;&lt;p&gt;Unlike sql I don’t have a fondness for closing angle brackets in html, so I did away with it in favor of a clojure vector based representation of html:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;defn layout &amp;#91;request body&amp;#93;
  &amp;#91;:html
    &amp;#91;:head
      &amp;#91;:meta {:name &amp;quot;viewport&amp;quot; :content &amp;quot;width=device-width, initial-scale=1&amp;quot;}&amp;#93;
      &amp;#91;:meta {:charset &amp;quot;utf-8&amp;quot;}&amp;#93;

      &amp;#91;:link {:href &amp;quot;/css/app.css&amp;quot; :type &amp;quot;text/css&amp;quot; :rel &amp;quot;stylesheet&amp;quot;}&amp;#93;
      &amp;#91;:script {:src &amp;quot;/js/app.js&amp;quot; :type &amp;quot;text/javascript&amp;quot;}&amp;#93;&amp;#93;
    &amp;#91;:body
      body&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And that’s that. Models, views, controllers and routes.&lt;/p&gt;&lt;h2&gt;Generators&lt;/h2&gt;&lt;p&gt;Why write all of this code when you don’t have to. Generate code statically, not in a macro and now we have the best of all worlds, quick code generation that you can edit and it’s just sitting there statically! Macros would have been similar but less visible.&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;coast gen migration create-posts title:text body:text
coast gen model posts
coast gen controller posts
coast gen view posts
coast gen mvc posts
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Testing&lt;/h2&gt;&lt;p&gt;There is testing too, not like capital T testing, since I usually make websites with no users, there’s no point to test anything. What I do do 😐 though is test my app at the repl, don’t even need a running http server to test things, you can make your coast app, bind it and call it as a function that takes a ring request map.&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;; src/controllers/home.clj
&amp;#40;ns controllers.home&amp;#41;

&amp;#40;defn index &amp;#91;request&amp;#93;
  &amp;#91;:div &amp;quot;hello world!&amp;quot;&amp;#93;&amp;#41;

; routes.clj
&amp;#40;ns routes
  &amp;#40;:require &amp;#91;coast.router :refer &amp;#91;get&amp;#93;&amp;#93;
            &amp;#91;controllers.home :as c.home&amp;#93;&amp;#41;&amp;#41;
  &amp;#40;:refer-clojure :exclude &amp;#91;get&amp;#93;&amp;#41;

&amp;#40;def routes &amp;#40;get &amp;quot;/&amp;quot; c.home/index&amp;#41;&amp;#41;

; server.clj
&amp;#40;ns server
  &amp;#40;:require &amp;#91;coast.beta :as coast&amp;#93;&amp;#41;&amp;#41;
            &amp;#91;routes :refer &amp;#91;routes&amp;#93;&amp;#93;

&amp;#40;def app &amp;#40;coast/app routes&amp;#41;&amp;#41;

&amp;#40;app {:request-method :get :uri &amp;quot;/&amp;quot;}&amp;#41; ; =&amp;gt; &amp;lt;div&amp;gt;hello world&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way coast (and clojure ring websites in general) works is that you then pass this function to an HTTP server that does all the dirty work of actually handling sockets and things, pretty cool right?&lt;/p&gt;&lt;h2&gt;Background Jobs&lt;/h2&gt;&lt;p&gt;I have come up with a very basic background jobs system, but it’s kind of a piece of garbage, it just polls the database every 10 seconds looking for jobs  to run. Here’s what jobs look like&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;# set up the jobs table
coast gen jobs
make db/migrate
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you have the jobs schema in the database, you can go ahead and start queuing stuff up&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;ns emails&amp;#41;

&amp;#40;defn send &amp;#91;m&amp;#93;
  ; doesn't actually send any emails
  &amp;#40;-&amp;gt; &amp;#40;select-keys m &amp;#91;:to :from :subject :text :html&amp;#93;&amp;#41;
      &amp;#40;println&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then when it’s time to queue up a job, you can do this&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;:require &amp;#91;coast.jobs :as jobs&amp;#93;&amp;#41;

&amp;#40;jobs/queue #'emails/send {:to &amp;quot;&amp;quot; :from &amp;quot;&amp;quot; :subject &amp;quot;&amp;quot; :text &amp;quot;&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can also schedule things to happen in the future&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;&amp;#40;:require &amp;#91;coast.jobs :as jobs&amp;#93;
          &amp;#91;coast.time :as time&amp;#93;&amp;#41;

&amp;#40;jobs/queue #'emails/send {:to &amp;quot;&amp;quot; :from &amp;quot;&amp;quot; :subject &amp;quot;&amp;quot; :text &amp;quot;&amp;quot;} &amp;#40;time/at 20 :minutes/from-now&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That’s &lt;a href='https://github.com/swlkr/coast'&gt;coast.beta&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>hollaback: show your visitors you're a person not a company</title><updated>March 16 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/03-16-2018-hollaback.html"></link><id>urn:swlkr-com:feed:post:hollaback: show your visitors you're a person not a company</id><content type="html">&lt;p&gt;Inspired by my introversion, &lt;a href='https://m.signalvnoise.com/theres-such-a-thing-as-too-helpful-91002b411a62'&gt;this post&lt;/a&gt; and &lt;a href='http://nomadlist.com/'&gt;nomad list&lt;/a&gt; I’m making &lt;a href='hollabackapp.com'&gt;hollaback&lt;/a&gt; a respectful way to show who you are to your website visitors. When I say respect, I mean don’t barge in trying to help them with a chatbox in their face. There’s nothing I like less than being sold to on a website. I expect it when I’m buying a car, but I don’t expect it when visiting your site. They don’t call it &lt;strong&gt;browsing&lt;/strong&gt; the web for nothing, let me browse, don’t try to help me. How does hollaback help you as a website owner? Well let me count the ways:&lt;/p&gt;&lt;h3&gt;Tell your visitors who you are up front, not behind an about link&lt;/h3&gt;&lt;p&gt;Contrary to popular belief, I like other people even though I tend to be more introverted most of the time, and when I visit a website, it helps me to know there’s a human or at least a team of people behind it. I usually reach for the about link if I’m encountering something new and interesting. It’s always nice to see who’s behind the site.&lt;/p&gt;&lt;h3&gt;Simple analytics&lt;/h3&gt;&lt;p&gt;I’m currently using google analytics but I don’t really understand it. I’m sure it works great for pros who know what they’re doing, but that’s not me, I don’t know what I’m doing, I just want to see which pages people are visiting and that’s probably it. All of the info on google analytics is overwhelming. I like the idea of a lot of info, but the way it’s laid out, at least to me, is confusing. So the idea here is to get some basic analytics, where are visitors coming from, what pages did they visit, etc. laid out in an easy way and that’ll be that.&lt;/p&gt;&lt;h3&gt;Build your personal brand&lt;/h3&gt;&lt;p&gt;The most important thing, I think to website owner’s success, is to build a personal brand. People follow people, not brands (at least I don’t). Products where I know someone who’s making it typically catch my attention much more than products made by seemingly anonymous people who I don’t really know. So, what’s better than seeing a face and a name behind a site right there on the site? I think it’ll be better for indie makers and better for visitors to get to know them&lt;/p&gt;&lt;h3&gt;One up faceless corporations with your face&lt;/h3&gt;&lt;p&gt;Is your website trying to compete with a large-ish corp? Well, good thing you’re an indie maker and the customers who do appreciate that sort of thing can make their buying decision easier knowing that it’s you and your face behind the product they’re buying, not just another corp with sales/customer service people who aren’t really into it.&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;Picking up what I’m putting down? Head over to &lt;a href='http://hollabackapp.com'&gt;hollaback&lt;/a&gt; to see what it’s all about it and don’t hesitate to sign up, it’s free! Also, send me an email or hit me up on &lt;a href='https://twitter.com/swlkr'&gt;twitter&lt;/a&gt; if you want to give me some feedback, it’s always welcome.&lt;/p&gt;</content></entry><entry><title>coast.alpha: an easy way to make websites with clojure</title><updated>March 10 2018</updated><author><name>Sean Walker</name></author><link href="http://swlkr.com/posts/03-10-2018-coast-alpha.html"></link><id>urn:swlkr-com:feed:post:coast.alpha: an easy way to make websites with clojure</id><content type="html">&lt;p&gt;Hot on the heels of coast 1.0 comes coast.alpha, why dot alpha and not 2.0?&lt;/p&gt;&lt;p&gt;Because I hate you.&lt;/p&gt;&lt;p&gt;No I'm kidding, I don't hate you! I really did it because there are so many new, incompatible changes, I'd rather just keep 1.0 going, still work on bug fixes and not pretend like you can just upgrade and have everything work out. If you try to upgrade from coast to coast.alpha, you aren't going to have a good time because they aren't the same! The name has changed! Haha!&lt;/p&gt;&lt;p&gt;With that out of the way, let's look at what's new:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;No more leiningen&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;It's a scary, brave new world out there in Clojure tooling land, but luckily, Clojure 1.9.0, tools.deps and makefiles have your back&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Easier namespace references&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I realized that since I'm making websites with coast, not libraries, there's no point to scatter the project name across every freakin namespace, just reference things from src/ and that's that&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Simpler and more explicit resource routing&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;This was mostly a library change, but it's worth mentioning, no more keywords, just symbols.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Simpler models&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;No more dynamic sql generation at all, every bit of sql is static and beautiful, with generators to help out for the inserts, updates and deletes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Less dependencies&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I've basically inlined everything that was a separate library before. This makes it so much easier to make underlying changes&lt;/p&gt;&lt;p&gt;&lt;strong&gt;A worker process&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The one thing coast was missing was a worker process and background jobs, it has it now, although it's kind of weird, just like coast itself, so hopefully someone can either give me a much better solution or just embrace the weird&lt;/p&gt;&lt;p&gt;There are probably other changes, mostly under the hood and the way the generators work since there's no more lein, but it's pretty straightforward... hopefully. Anyway, give it a star on github or at the very least check it out and see if it works for you!&lt;/p&gt;</content></entry></feed>